from __future__ import annotations

import json
from typing import Any, Dict, List, Optional

from .prompts import SYSTEM_SLIDE_PLANNER, USER_SLIDE_PLANNER_TEMPLATE
from .utils import LLMClient, dict_get_first, shorten, text_similarity


Slide = Dict[str, Any]


class SlidePlanner:
    """
    Convert structured project information into a slide plan.

    If an LLM client is provided, it can be used to refine the slide outline.
    In the default pipeline we call this module without LLM for determinism,
    but users can also manually use the LLM-enabled path.
    """

    def __init__(self, llm_client: Optional[LLMClient] = None, language: str = "en") -> None:
        self.llm_client = llm_client
        self.language = "zh" if language.lower().startswith("zh") else "en"

    def plan_slides(self, content: Dict[str, str]) -> List[Slide]:
        if self.llm_client:
            try:
                slides = self._plan_with_llm(content)
                return self._post_process(slides)
            except Exception:
                # fall back to heuristic if LLM fails
                pass
        return self._post_process(self._plan_heuristic(content))

    def _plan_with_llm(self, content: Dict[str, str]) -> List[Slide]:
        structured_json = json.dumps(content, ensure_ascii=False, indent=2)
        user_prompt = USER_SLIDE_PLANNER_TEMPLATE.format(
            structured_json=shorten(structured_json, 6000)
        )
        raw = self.llm_client.chat(system_prompt=SYSTEM_SLIDE_PLANNER, user_prompt=user_prompt)
        try:
            data = json.loads(raw)
        except json.JSONDecodeError:
            start = raw.find("[")
            end = raw.rfind("]")
            if start != -1 and end != -1 and end > start:
                try:
                    data = json.loads(raw[start : end + 1])
                except json.JSONDecodeError:
                    data = []
            else:
                data = []

        slides: List[Slide] = []
        if isinstance(data, list):
            for item in data:
                if not isinstance(item, dict):
                    continue
                title = str(item.get("title", "")).strip() or "Slide"
                bullets_raw = item.get("bullets", [])
                if isinstance(bullets_raw, list):
                    bullets = [str(b).strip() for b in bullets_raw if str(b).strip()]
                else:
                    bullets = [str(bullets_raw).strip()]
                slides.append({"title": title, "bullets": bullets})

        if 8 <= len(slides) <= 12:
            return slides
        # If LLM went off rails, fall back to heuristic
        return self._plan_heuristic(content)

    def _plan_heuristic(self, content: Dict[str, str]) -> List[Slide]:
        title = dict_get_first(content, ["title"], default="Project Overview")
        background = dict_get_first(content, ["background"])
        problem = dict_get_first(content, ["problem"])
        method = dict_get_first(content, ["method"])
        architecture = dict_get_first(content, ["architecture"])
        experiments = dict_get_first(content, ["experiments"])
        results = dict_get_first(content, ["results"])
        conclusion = dict_get_first(content, ["conclusion"])
        future_work = dict_get_first(content, ["future_work"])

        slides: List[Slide] = []

        if self.language == "zh":
            title_slide = {
                "title": title or "项目概览",
                "bullets": [
                    "项目整体介绍",
                    "基于仓库的代码与实验",
                    "由 Repo2Slides 自动生成 PPT 大纲",
                ],
            }
            agenda = [
                "背景与动机",
                "问题定义与目标",
                "方法概述",
                "系统架构",
                "实验设置与结果",
                "总结与未来工作",
            ]
            bg_title = "背景与动机"
            prob_title = "问题定义与目标"
            method_title = "方法概述"
            arch_title = "系统架构"
            exp_title = "实验设置"
            res_title = "实验结果与分析"
            concl_title = "总结"
            future_title = "未来工作"
        else:
            title_slide = {
                "title": title or "Project Overview",
                "bullets": [
                    "Project overview",
                    "Repository-based code & experiments",
                    "Automatically generated by Repo2Slides",
                ],
            }
            agenda = [
                "Background & motivation",
                "Problem definition",
                "Method overview",
                "System architecture",
                "Experiments & results",
                "Conclusion & future work",
            ]
            bg_title = "Background & Motivation"
            prob_title = "Problem Definition & Goals"
            method_title = "Method Overview"
            arch_title = "System Architecture"
            exp_title = "Experimental Setup"
            res_title = "Results & Analysis"
            concl_title = "Conclusion"
            future_title = "Future Work"

        # 1. Title slide
        slides.append(title_slide)

        # 2. Outline / Agenda (academic talks usually benefit from this)
        slides.append({"title": "Outline" if self.language == "en" else "目录", "bullets": agenda})

        # 3. Background & motivation
        if background:
            slides.append(
                {
                    "title": bg_title,
                    "bullets": self._split_paragraph(background, max_bullets=5),
                }
            )

        # 4. Problem definition & goals
        if problem:
            slides.append(
                {
                    "title": prob_title,
                    "bullets": self._split_paragraph(problem, max_bullets=5),
                }
            )

        # 5. Method overview
        if method:
            slides.append(
                {
                    "title": method_title,
                    "bullets": self._split_paragraph(method, max_bullets=6),
                }
            )

        # 6. Architecture / system design
        if architecture:
            slides.append(
                {
                    "title": arch_title,
                    "bullets": self._split_paragraph(architecture, max_bullets=6),
                }
            )

        # 7. Experiments
        if experiments:
            slides.append(
                {
                    "title": exp_title,
                    "bullets": self._split_paragraph(experiments, max_bullets=6),
                }
            )

        # 8. Results
        if results:
            slides.append(
                {
                    "title": res_title,
                    "bullets": self._split_paragraph(results, max_bullets=6),
                }
            )

        # 9. Conclusion
        if conclusion:
            slides.append(
                {
                    "title": concl_title,
                    "bullets": self._split_paragraph(conclusion, max_bullets=5),
                }
            )

        # 10. Future work
        if future_work:
            slides.append(
                {
                    "title": future_title,
                    "bullets": self._split_paragraph(future_work, max_bullets=5),
                }
            )

        # Ensure slide count between 8 and 12 by adding / trimming.
        filler_pool: List[Slide] = [
            {
                "title": "Implementation Details",
                "bullets": [
                    "Key modules and entry points",
                    "Data / control flow between components",
                    "Engineering choices and trade-offs",
                ],
            },
            {
                "title": "Limitations",
                "bullets": [
                    "Assumptions made by the project",
                    "Known failure cases / edge cases",
                    "What is not covered yet",
                ],
            },
            {
                "title": "Summary",
                "bullets": [
                    "Recap of problem and motivation",
                    "High-level method and architecture",
                    "Key experimental findings and takeaways",
                ],
            },
        ]

        while len(slides) < 8 and filler_pool:
            slides.append(filler_pool.pop(0))

        # Always end with Conclusion / Future Work if present by moving them to the end.
        tail_titles = {"Conclusion", "Future Work"}
        tail = [s for s in slides if str(s.get("title")) in tail_titles]
        body = [s for s in slides if str(s.get("title")) not in tail_titles]
        slides = body + tail

        if len(slides) > 12:
            # Keep title + outline + core technical slides; trim less essential ones in the middle.
            head = slides[:2]
            core = slides[2:]
            slides = head + core[:10]

        return slides

    @staticmethod
    def _split_paragraph(text: str, max_bullets: int = 5) -> List[str]:
        """
        Very lightweight splitting of a paragraph into bullet-like sentences.
        """
        raw = text.replace("\r\n", "\n").replace("\r", "\n")
        # If the text already has markdown bullets, respect ONLY those bullet lines.
        bullet_lines: List[str] = []
        for ln in raw.splitlines():
            s = ln.strip()
            if not s:
                continue
            if SlidePlanner._is_setext_underline(s):
                continue
            if s.startswith(("-", "*", "•")):
                bullet_lines.append(s.lstrip("-*•").strip())
                continue
            # simple numbered list: "1. xxx" or "1) xxx"
            if len(s) >= 3 and s[0].isdigit() and s[1] in {".", ")"} and s[2] == " ":
                bullet_lines.append(s[3:].strip())
                continue
        if len(bullet_lines) >= 2:
            return bullet_lines[:max_bullets]

        # Otherwise, split on periods / Chinese full stops as a heuristic.
        parts = []
        for sep in [".", "。", "!", "？", "?"]:
            new_parts = []
            for chunk in (parts or [raw]):
                new_parts.extend(chunk.split(sep))
            parts = new_parts
        bullets = [p.strip() for p in parts if p.strip() and not SlidePlanner._is_setext_underline(p.strip())]
        if not bullets:
            bullets = [raw.strip()]
        return bullets[:max_bullets]

    @staticmethod
    def _is_setext_underline(line: str) -> bool:
        """
        Detect Markdown Setext underline lines like "=====" or "-----".
        """
        s = line.strip()
        if len(s) < 3:
            return False
        return all(ch == "=" for ch in s) or all(ch == "-" for ch in s)

    def _post_process(self, slides: List[Slide]) -> List[Slide]:
        """
        Make the slide deck more usable:
        - de-duplicate bullets within and across slides
        - drop or shrink redundant slides (e.g., Problem repeats Background)
        - enforce 8–12 slide constraint
        """
        cleaned: List[Slide] = []
        seen_bullets: List[str] = []

        for slide in slides:
            title = str(slide.get("title", "")).strip() or "Slide"
            bullets_raw = slide.get("bullets", [])
            if not isinstance(bullets_raw, list):
                bullets_raw = [str(bullets_raw)]

            bullets: List[str] = []
            for b in bullets_raw:
                s = str(b).strip()
                if not s:
                    continue
                # remove obvious underline noise
                if self._is_setext_underline(s):
                    continue
                # local dedup inside slide
                if any(text_similarity(s, x) >= 0.92 for x in bullets):
                    continue
                # global dedup across deck (more strict)
                if any(text_similarity(s, x) >= 0.94 for x in seen_bullets):
                    continue
                bullets.append(s)

            if bullets:
                cleaned.append({"title": title, "bullets": bullets[:6]})
                seen_bullets.extend(bullets[:6])

        # Drop redundant "Problem" if too similar to "Background"
        bg_idx = next((i for i, s in enumerate(cleaned) if str(s.get("title", "")).lower().startswith("background")), None)
        pr_idx = next((i for i, s in enumerate(cleaned) if str(s.get("title", "")).lower().startswith("problem")), None)
        if bg_idx is not None and pr_idx is not None:
            bg_text = " ".join(cleaned[bg_idx].get("bullets", []))
            pr_text = " ".join(cleaned[pr_idx].get("bullets", []))
            if text_similarity(bg_text, pr_text) >= 0.88:
                # keep the later slide but shrink it to unique bullets
                cleaned.pop(pr_idx)

        # Enforce 8–12: if too short, add a generic Q&A / References; if too long, trim middle.
        if len(cleaned) < 8:
            cleaned.append(
                {
                    "title": "Q&A",
                    "bullets": [
                        "Questions and discussion",
                        "Clarifications on method and experiments",
                    ],
                }
            )
        if len(cleaned) < 8:
            cleaned.append(
                {
                    "title": "References",
                    "bullets": [
                        "Repository README and documentation",
                        "Related work (if applicable)",
                    ],
                }
            )

        if len(cleaned) > 12:
            head = cleaned[:2]
            tail = cleaned[-2:] if len(cleaned) >= 4 else []
            mid = cleaned[2:-2]
            cleaned = head + mid[: (12 - len(head) - len(tail))] + tail

        return cleaned[:12]

